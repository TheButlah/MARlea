{"message":"unused import: `reaction::Reaction`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":67,"byte_end":85,"line_start":3,"line_end":3,"column_start":41,"column_end":59,"is_primary":true,"text":[{"text":"use reaction_network::{ReactionNetwork, reaction::Reaction, reaction::term::species::Species};","highlight_start":41,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":65,"byte_end":85,"line_start":3,"line_end":3,"column_start":39,"column_end":59,"is_primary":true,"text":[{"text":"use reaction_network::{ReactionNetwork, reaction::Reaction, reaction::term::species::Species};","highlight_start":39,"highlight_end":59}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `reaction::Reaction`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:3:41\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse reaction_network::{ReactionNetwork, reaction::Reaction, reaction::term::species::Species};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `HashSet`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":145,"byte_end":152,"line_start":4,"line_end":4,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"use std::collections::{HashSet, HashMap};","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":145,"byte_end":154,"line_start":4,"line_end":4,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"use std::collections::{HashSet, HashMap};","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `HashSet`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:4:24\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::collections::{HashSet, HashMap};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `self::reaction_network::reaction`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":169,"byte_end":201,"line_start":6,"line_end":6,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"use self::reaction_network::reaction;","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":165,"byte_end":202,"line_start":6,"line_end":6,"column_start":1,"column_end":38,"is_primary":true,"text":[{"text":"use self::reaction_network::reaction;","highlight_start":1,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `self::reaction_network::reaction`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:6:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse self::reaction_network::reaction;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `std::env::Args`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":20,"byte_end":34,"line_start":3,"line_end":3,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use std::env::Args;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":16,"byte_end":35,"line_start":3,"line_end":3,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"use std::env::Args;","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `std::env::Args`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::env::Args;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot use `*self` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `self.0` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":653,"byte_end":657,"line_start":20,"line_end":20,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"            match self {","highlight_start":19,"highlight_end":23}],"label":"use of borrowed `self.0`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0503]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot use `*self` because it was mutably borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:20:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of borrowed `self.0`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `self.0` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1007,"byte_end":1012,"line_start":26,"line_end":26,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Stable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:26:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Stable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1215,"byte_end":1220,"line_start":29,"line_end":29,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::SemiStable(reaction_network.clone(), 0);","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:29:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::SemiStable(reaction_network.clone(), 0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1349,"byte_end":1354,"line_start":32,"line_end":32,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Unstable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:32:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Unstable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot borrow `self.0` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":1483,"byte_end":1499,"line_start":35,"line_end":35,"column_start":38,"column_end":54,"is_primary":true,"text":[{"text":"                TrialState::Unstable(reaction_network) => {","highlight_start":38,"highlight_end":54}],"label":"`self.0` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1780,"byte_end":1821,"line_start":37,"line_end":37,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `self.0` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:35:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::Unstable(reaction_network) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`self.0` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction_netowrk is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":577,"byte_end":578,"line_start":18,"line_end":18,"column_start":22,"column_end":23,"is_primary":false,"text":[{"text":"    pub fn simulate (&mut self) -> HashMap<&Species, Species> {","highlight_start":22,"highlight_end":23}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1780,"byte_end":1821,"line_start":37,"line_end":37,"column_start":46,"column_end":87,"is_primary":true,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `'1` must outlive `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:37:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn simulate (&mut self) -> HashMap<&Species, Species> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9margument requires that `'1` must outlive `'reacting`\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1903,"byte_end":1908,"line_start":40,"line_end":40,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Stable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:40:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Stable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed as immutable was borrowed as mutable.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2227,"byte_end":2264,"line_start":44,"line_end":44,"column_start":29,"column_end":66,"is_primary":true,"text":[{"text":"                            reaction_network.react(next_reaction);","highlight_start":29,"highlight_end":66}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1780,"byte_end":1821,"line_start":37,"line_end":37,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":2244,"byte_end":2249,"line_start":44,"line_end":44,"column_start":46,"column_end":51,"is_primary":false,"text":[{"text":"                            reaction_network.react(next_reaction);","highlight_start":46,"highlight_end":51}],"label":"immutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0502]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:44:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            reaction_network.react(next_reaction);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow later used by call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmutable borrow occurs here\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":2316,"byte_end":2321,"line_start":46,"line_end":46,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::SemiStable(reaction_network.clone(), 0);","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:46:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::SemiStable(reaction_network.clone(), 0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed as immutable was borrowed as mutable.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2566,"byte_end":2603,"line_start":50,"line_end":50,"column_start":29,"column_end":66,"is_primary":true,"text":[{"text":"                            reaction_network.react(next_reaction);","highlight_start":29,"highlight_end":66}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":1780,"byte_end":1821,"line_start":37,"line_end":37,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":2583,"byte_end":2588,"line_start":50,"line_end":50,"column_start":46,"column_end":51,"is_primary":false,"text":[{"text":"                            reaction_network.react(next_reaction);","highlight_start":46,"highlight_end":51}],"label":"immutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0502]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:50:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            reaction_network.react(next_reaction);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow later used by call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmutable borrow occurs here\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":2655,"byte_end":2660,"line_start":52,"line_end":52,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Unstable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:52:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Unstable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot borrow `self.0` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"`self.0` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `self.0` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:55:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`self.0` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3292,"byte_end":3297,"line_start":60,"line_end":60,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Stable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:60:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Stable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\n"}
{"message":"cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed as immutable was borrowed as mutable.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":3666,"byte_end":3703,"line_start":65,"line_end":65,"column_start":33,"column_end":70,"is_primary":true,"text":[{"text":"                                reaction_network.react(next_reaction);","highlight_start":33,"highlight_end":70}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3683,"byte_end":3688,"line_start":65,"line_end":65,"column_start":50,"column_end":55,"is_primary":false,"text":[{"text":"                                reaction_network.react(next_reaction);","highlight_start":50,"highlight_end":55}],"label":"immutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0502]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:65:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                reaction_network.react(next_reaction);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow later used by call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmutable borrow occurs here\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3763,"byte_end":3768,"line_start":67,"line_end":67,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"                            *self = TrialState::SemiStable(reaction_network.clone(), *count + 1);","highlight_start":29,"highlight_end":34}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:67:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is unstable, \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            *self = TrialState::SemiStable(reaction_network.clone(), *count + 1);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\n"}
{"message":"cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable","code":{"code":"E0502","explanation":"A variable already borrowed as immutable was borrowed as mutable.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":4038,"byte_end":4075,"line_start":71,"line_end":71,"column_start":33,"column_end":70,"is_primary":true,"text":[{"text":"                                reaction_network.react(next_reaction);","highlight_start":33,"highlight_end":70}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":4055,"byte_end":4060,"line_start":71,"line_end":71,"column_start":50,"column_end":55,"is_primary":false,"text":[{"text":"                                reaction_network.react(next_reaction);","highlight_start":50,"highlight_end":55}],"label":"immutable borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0502]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot borrow `*reaction_network` as mutable because it is also borrowed as immutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:71:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                                reaction_network.react(next_reaction);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimmutable borrow later used by call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmutable borrow occurs here\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":4135,"byte_end":4140,"line_start":73,"line_end":73,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"                            *self = TrialState::Stable(reaction_network.clone());","highlight_start":29,"highlight_end":34}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:73:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                            *self = TrialState::Stable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\n"}
{"message":"cannot assign to `*self` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src\\trial\\mod.rs","byte_start":2790,"byte_end":2806,"line_start":55,"line_end":55,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"                TrialState::SemiStable(reaction_network, count) => {","highlight_start":40,"highlight_end":56}],"label":"borrow of `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":4288,"byte_end":4293,"line_start":77,"line_end":77,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                        *self = TrialState::Unstable(reaction_network.clone());","highlight_start":25,"highlight_end":30}],"label":"assignment to borrowed `*self` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":520,"byte_end":529,"line_start":16,"line_end":16,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl<'reacting> TrialState<'reacting> {","highlight_start":6,"highlight_end":15}],"label":"lifetime `'reacting` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\trial\\mod.rs","byte_start":3169,"byte_end":3210,"line_start":57,"line_end":57,"column_start":46,"column_end":87,"is_primary":false,"text":[{"text":"                    let possible_reactions = reaction_network.get_possible_reactions();","highlight_start":46,"highlight_end":87}],"label":"argument requires that `self.0` is borrowed for `'reacting`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0506]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot assign to `*self` because it is borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\trial\\mod.rs:77:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<'reacting> TrialState<'reacting> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mlifetime `'reacting` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                TrialState::SemiStable(reaction_network, count) => {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mborrow of `*self` occurs here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    // get possible reactions then determine if reaction network is \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let possible_reactions = reaction_network.get_possible_reactions();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14margument requires that `self.0` is borrowed for `'reacting`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        *self = TrialState::Unstable(reaction_network.clone());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massignment to borrowed `*self` occurs here\u001b[0m\n\n"}
{"message":"aborting due to 18 previous errors; 4 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 18 previous errors; 4 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0499, E0502, E0503, E0506.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0499, E0502, E0503, E0506.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0499`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0499`.\u001b[0m\n"}
